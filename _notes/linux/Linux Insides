Linux Insides
====

# Booting

## The Magical Power Button, What happens next? 

1. The CS register consists of two parts: the visible segment selector and the hidden base address.

2. Since only one megabyte is accessible in real mode, 0x10ffef becomes 0x00ffef with disabled A20 line.

3. 0xfffffff0, which is 16 bytes below 4GB, this point is called the Reset vector --  the default location a central processing unit will go to find the first instruction it will execute after a reset. It contains a jump (jmp) instruction that usually points to the BIOS entry point.

ROM mapped to this address with the instruction.

4. Now the BIOS starts; after initializing and checking the hardware, the BIOS needs to find a bootable device.

5. 80386 registers:

EIP         0xfff0
CS selector 0xf000
CS base     0xffff0000

 All memory is divided into small, fixed-size segments of 65536 bytes (64 KB). 

 An address consists of two parts: a segment selector, which has a base address, and an offset from this base address. 

 PhysicalAddress = Segment Selector * 16 + Offset

 6. during a hardware reset the segment selector in the CS register is loaded with 0xf000 and the base address is loaded with 0xffff0000; the processor uses this special base address until CS is changed.

 7. The starting address is formed by adding the base address to the value in the EIP register.

 8. A boot order is stored in the BIOS configuration, controlling which devices the BIOS attempts to boot from.

 9. MBR partition layout: Master boot record

    On hard drives partitioned with an MBR partition layout, the boot sector is stored in the first 446 bytes of the first sector, where each sector is 512 bytes.

    The final two bytes of the first sector are 0x55 and 0xaa, which designates to the BIOS that this device is bootable.

 10. https://www.qemu.org
 11. http://www.nasm.us/doc/nasmdoc1.html
 12.  Since the binary generated by the assembly code above fulfills the requirements of the boot sector (the origin is set to 0x7c00 and we end with the magic sequence), QEMU will treat the binary as the master boot record (MBR) of a disk image.
 13. A real-world boot sector has code for continuing the boot process and a partition table. From this point onwards, the BIOS hands over control to the bootloader.

 13. memory map of processor: 

0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table
0x00000400 - 0x000004FF - BIOS Data Area
0x00000500 - 0x00007BFF - Unused
0x00007C00 - 0x00007DFF - Our Bootloader
0x00007E00 - 0x0009FFFF - Unused
0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory
0x000B0000 - 0x000B7777 - Monochrome Video Memory
0x000B8000 - 0x000BFFFF - Color Video Memory
0x000C0000 - 0x000C7FFF - Video ROM BIOS
0x000C8000 - 0x000EFFFF - BIOS Shadow Area
0x000F0000 - 0x000FFFFF - System BIOS

## Bootloader

14. Note that the copy isn't done by some magic circuitry, it is just done by the bios itself when it starts executing out of ROM initially, it just copies itself to RAM and then continues executing from there. 

> https://superuser.com/questions/336021/is-bios-read-from-the-bios-chip-or-copied-into-ram-on-startup

15. The bootloader has now 
    1. loaded the Linux kernel into memory, 
    2. filled the header fields, 
    3. and then jumped to the corresponding memory address. 

## Start of Kernel Setup

1. first, the kernel setup part must configure some stuff like decompressor, memory management related things and etc.

After all of such things, kernel setup part will decompress actual kernel and jump on it. 

Execution of setup part starts from arch/x86/boot/header.S at _start. 

2. After the jump to start_of_setup, the kernel needs to do the following: ????
    1. Make sure that all segment register values are equal (Segment registers align)
    2. Set up a correct stack, if needed (Stack Setup)
    3. Set up bss (BSS Setup)
    4. Jump to the C code in main.c
       `calll main`

 > http://mikeos.sourceforge.net/write-your-own-os.html#requirements

 3.  to test
    1. $ nasm -f elf test.asm // create an object file
    2.1 $ ld test.o -o test // Your program begins with a procedure called "_start". This means that your program has its own point of entry without the use of the main function. However, you'll need to use the "l" to create your executable
    2.2 $ gcc test.o -o test // Your program begins with a procedure called "main". You will need to use gcc to create your executable







